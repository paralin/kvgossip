// Code generated by protoc-gen-go.
// source: github.com/fuserobotics/kvgossip/sync/sync-service.proto
// DO NOT EDIT!

/*
Package sync is a generated protocol buffer package.

It is generated from these files:
	github.com/fuserobotics/kvgossip/sync/sync-service.proto

It has these top-level messages:
	SyncGlobalHash
	SyncKeyHash
	SyncKey
	SyncKeyResult
	SyncSessionMessage
*/
package sync

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import tx "github.com/fuserobotics/kvgossip/tx"
import data "github.com/fuserobotics/kvgossip/data"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Offer our global tree hash.
type SyncGlobalHash struct {
	KvgossipVersion string `protobuf:"bytes,1,opt,name=kvgossip_version,json=kvgossipVersion" json:"kvgossip_version,omitempty"`
	GlobalTreeHash  []byte `protobuf:"bytes,2,opt,name=global_tree_hash,json=globalTreeHash,proto3" json:"global_tree_hash,omitempty"`
	HostNonce       string `protobuf:"bytes,3,opt,name=host_nonce,json=hostNonce" json:"host_nonce,omitempty"`
}

func (m *SyncGlobalHash) Reset()                    { *m = SyncGlobalHash{} }
func (m *SyncGlobalHash) String() string            { return proto.CompactTextString(m) }
func (*SyncGlobalHash) ProtoMessage()               {}
func (*SyncGlobalHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SyncGlobalHash) GetKvgossipVersion() string {
	if m != nil {
		return m.KvgossipVersion
	}
	return ""
}

func (m *SyncGlobalHash) GetGlobalTreeHash() []byte {
	if m != nil {
		return m.GlobalTreeHash
	}
	return nil
}

func (m *SyncGlobalHash) GetHostNonce() string {
	if m != nil {
		return m.HostNonce
	}
	return ""
}

// Offer our local hash for a key.
// Response will be a 1 in the timestamp field for agreement.
type SyncKeyHash struct {
	Key       string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Hash      []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Timestamp uint64 `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *SyncKeyHash) Reset()                    { *m = SyncKeyHash{} }
func (m *SyncKeyHash) String() string            { return proto.CompactTextString(m) }
func (*SyncKeyHash) ProtoMessage()               {}
func (*SyncKeyHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SyncKeyHash) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SyncKeyHash) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *SyncKeyHash) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// Response to SyncKeyHash disagreement.
// request_key will be set to the key if we want the peer's value.
// Otherwise, transaction will be set to OUR value.
type SyncKey struct {
	RequestKey  string          `protobuf:"bytes,1,opt,name=request_key,json=requestKey" json:"request_key,omitempty"`
	Transaction *tx.Transaction `protobuf:"bytes,2,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *SyncKey) Reset()                    { *m = SyncKey{} }
func (m *SyncKey) String() string            { return proto.CompactTextString(m) }
func (*SyncKey) ProtoMessage()               {}
func (*SyncKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SyncKey) GetRequestKey() string {
	if m != nil {
		return m.RequestKey
	}
	return ""
}

func (m *SyncKey) GetTransaction() *tx.Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

// Response to SyncKey.
type SyncKeyResult struct {
	// If we are rejecting the sync, return the relevant revocations.
	Revocations []*data.SignedData `protobuf:"bytes,1,rep,name=revocations" json:"revocations,omitempty"`
	// Otherwise, just echo back the key.
	UpdatedKey string `protobuf:"bytes,2,opt,name=updated_key,json=updatedKey" json:"updated_key,omitempty"`
	// Additionally, if we still disagree (in the event of a deleted key) send the tx.
	DeleteTransaction *tx.Transaction `protobuf:"bytes,3,opt,name=delete_transaction,json=deleteTransaction" json:"delete_transaction,omitempty"`
}

func (m *SyncKeyResult) Reset()                    { *m = SyncKeyResult{} }
func (m *SyncKeyResult) String() string            { return proto.CompactTextString(m) }
func (*SyncKeyResult) ProtoMessage()               {}
func (*SyncKeyResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SyncKeyResult) GetRevocations() []*data.SignedData {
	if m != nil {
		return m.Revocations
	}
	return nil
}

func (m *SyncKeyResult) GetUpdatedKey() string {
	if m != nil {
		return m.UpdatedKey
	}
	return ""
}

func (m *SyncKeyResult) GetDeleteTransaction() *tx.Transaction {
	if m != nil {
		return m.DeleteTransaction
	}
	return nil
}

// A message in a sync session conversation.
type SyncSessionMessage struct {
	SyncGlobalHash *SyncGlobalHash `protobuf:"bytes,1,opt,name=sync_global_hash,json=syncGlobalHash" json:"sync_global_hash,omitempty"`
	SyncKeyHash    *SyncKeyHash    `protobuf:"bytes,2,opt,name=sync_key_hash,json=syncKeyHash" json:"sync_key_hash,omitempty"`
	SyncKey        *SyncKey        `protobuf:"bytes,3,opt,name=sync_key,json=syncKey" json:"sync_key,omitempty"`
	SyncKeyResult  *SyncKeyResult  `protobuf:"bytes,4,opt,name=sync_key_result,json=syncKeyResult" json:"sync_key_result,omitempty"`
}

func (m *SyncSessionMessage) Reset()                    { *m = SyncSessionMessage{} }
func (m *SyncSessionMessage) String() string            { return proto.CompactTextString(m) }
func (*SyncSessionMessage) ProtoMessage()               {}
func (*SyncSessionMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SyncSessionMessage) GetSyncGlobalHash() *SyncGlobalHash {
	if m != nil {
		return m.SyncGlobalHash
	}
	return nil
}

func (m *SyncSessionMessage) GetSyncKeyHash() *SyncKeyHash {
	if m != nil {
		return m.SyncKeyHash
	}
	return nil
}

func (m *SyncSessionMessage) GetSyncKey() *SyncKey {
	if m != nil {
		return m.SyncKey
	}
	return nil
}

func (m *SyncSessionMessage) GetSyncKeyResult() *SyncKeyResult {
	if m != nil {
		return m.SyncKeyResult
	}
	return nil
}

func init() {
	proto.RegisterType((*SyncGlobalHash)(nil), "sync.SyncGlobalHash")
	proto.RegisterType((*SyncKeyHash)(nil), "sync.SyncKeyHash")
	proto.RegisterType((*SyncKey)(nil), "sync.SyncKey")
	proto.RegisterType((*SyncKeyResult)(nil), "sync.SyncKeyResult")
	proto.RegisterType((*SyncSessionMessage)(nil), "sync.SyncSessionMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SyncService service

type SyncServiceClient interface {
	SyncSession(ctx context.Context, opts ...grpc.CallOption) (SyncService_SyncSessionClient, error)
}

type syncServiceClient struct {
	cc *grpc.ClientConn
}

func NewSyncServiceClient(cc *grpc.ClientConn) SyncServiceClient {
	return &syncServiceClient{cc}
}

func (c *syncServiceClient) SyncSession(ctx context.Context, opts ...grpc.CallOption) (SyncService_SyncSessionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SyncService_serviceDesc.Streams[0], c.cc, "/sync.SyncService/SyncSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &syncServiceSyncSessionClient{stream}
	return x, nil
}

type SyncService_SyncSessionClient interface {
	Send(*SyncSessionMessage) error
	Recv() (*SyncSessionMessage, error)
	grpc.ClientStream
}

type syncServiceSyncSessionClient struct {
	grpc.ClientStream
}

func (x *syncServiceSyncSessionClient) Send(m *SyncSessionMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *syncServiceSyncSessionClient) Recv() (*SyncSessionMessage, error) {
	m := new(SyncSessionMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SyncService service

type SyncServiceServer interface {
	SyncSession(SyncService_SyncSessionServer) error
}

func RegisterSyncServiceServer(s *grpc.Server, srv SyncServiceServer) {
	s.RegisterService(&_SyncService_serviceDesc, srv)
}

func _SyncService_SyncSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SyncServiceServer).SyncSession(&syncServiceSyncSessionServer{stream})
}

type SyncService_SyncSessionServer interface {
	Send(*SyncSessionMessage) error
	Recv() (*SyncSessionMessage, error)
	grpc.ServerStream
}

type syncServiceSyncSessionServer struct {
	grpc.ServerStream
}

func (x *syncServiceSyncSessionServer) Send(m *SyncSessionMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *syncServiceSyncSessionServer) Recv() (*SyncSessionMessage, error) {
	m := new(SyncSessionMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SyncService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sync.SyncService",
	HandlerType: (*SyncServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncSession",
			Handler:       _SyncService_SyncSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/fuserobotics/kvgossip/sync/sync-service.proto",
}

func init() {
	proto.RegisterFile("github.com/fuserobotics/kvgossip/sync/sync-service.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x53, 0x5f, 0x8b, 0xd3, 0x4e,
	0x14, 0xfd, 0xcd, 0xb6, 0xfc, 0xd6, 0xde, 0xd8, 0x3f, 0x3b, 0xfa, 0x10, 0x8a, 0x62, 0xc9, 0x53,
	0x7c, 0x30, 0x5d, 0x2b, 0x0b, 0x82, 0xb0, 0x4f, 0xc2, 0x0a, 0xa2, 0xe0, 0x74, 0xd9, 0x37, 0x09,
	0xd3, 0xe4, 0x9a, 0x84, 0xb6, 0x99, 0x9a, 0x3b, 0x29, 0x9b, 0x77, 0x3f, 0x8a, 0x9f, 0xd0, 0x4f,
	0x20, 0x33, 0x49, 0x4d, 0x02, 0xca, 0xbe, 0x84, 0x99, 0x73, 0xef, 0x39, 0xf7, 0xe4, 0xde, 0x3b,
	0xf0, 0x36, 0xc9, 0x74, 0x5a, 0x6e, 0x82, 0x48, 0xed, 0x97, 0xdf, 0x4a, 0xc2, 0x42, 0x6d, 0x94,
	0xce, 0x22, 0x5a, 0x6e, 0x8f, 0x89, 0x22, 0xca, 0x0e, 0x4b, 0xaa, 0xf2, 0xc8, 0x7e, 0x5e, 0x11,
	0x16, 0xc7, 0x2c, 0xc2, 0xe0, 0x50, 0x28, 0xad, 0xf8, 0xd0, 0x60, 0xf3, 0xab, 0x07, 0xf9, 0xfa,
	0x7e, 0xa9, 0x0b, 0x99, 0x93, 0x8c, 0x74, 0xa6, 0xf2, 0x9a, 0x3c, 0xbf, 0x7c, 0x90, 0x16, 0x4b,
	0x2d, 0xed, 0xa7, 0x66, 0x78, 0x3f, 0x18, 0x4c, 0xd6, 0x55, 0x1e, 0xdd, 0xec, 0xd4, 0x46, 0xee,
	0x3e, 0x48, 0x4a, 0xf9, 0x4b, 0x98, 0x9d, 0xd2, 0xc3, 0x23, 0x16, 0x94, 0xa9, 0xdc, 0x65, 0x0b,
	0xe6, 0x8f, 0xc4, 0xf4, 0x84, 0xdf, 0xd5, 0x30, 0xf7, 0x61, 0x96, 0x58, 0x62, 0xa8, 0x0b, 0xc4,
	0x30, 0x95, 0x94, 0xba, 0x67, 0x0b, 0xe6, 0x3f, 0x16, 0x93, 0x1a, 0xbf, 0x2d, 0x10, 0xad, 0xe8,
	0x73, 0x80, 0x54, 0x91, 0x0e, 0x73, 0x95, 0x47, 0xe8, 0x0e, 0xac, 0xdc, 0xc8, 0x20, 0x9f, 0x0d,
	0xe0, 0x7d, 0x01, 0xc7, 0xb8, 0xf8, 0x88, 0x95, 0xcd, 0x9e, 0xc1, 0x60, 0x8b, 0x55, 0x53, 0xd5,
	0x1c, 0x39, 0x87, 0x61, 0x47, 0xdd, 0x9e, 0xf9, 0x33, 0x18, 0xe9, 0x6c, 0x8f, 0xa4, 0xe5, 0xfe,
	0x60, 0x25, 0x87, 0xa2, 0x05, 0xbc, 0xaf, 0x70, 0xde, 0x48, 0xf2, 0x17, 0xe0, 0x14, 0xf8, 0xbd,
	0x44, 0xd2, 0x61, 0x2b, 0x0b, 0x0d, 0x64, 0x12, 0x5e, 0x83, 0xd3, 0x69, 0xa6, 0x2d, 0xe2, 0xac,
	0xa6, 0x81, 0xbe, 0x0f, 0x6e, 0x5b, 0x58, 0x74, 0x73, 0xbc, 0x9f, 0x0c, 0xc6, 0x8d, 0xbe, 0x40,
	0x2a, 0x77, 0x9a, 0xaf, 0x4c, 0x95, 0xa3, 0x8a, 0xa4, 0x89, 0x93, 0xcb, 0x16, 0x03, 0xdf, 0x59,
	0xcd, 0x02, 0xdb, 0xec, 0x75, 0x96, 0xe4, 0x18, 0xbf, 0x97, 0x5a, 0x8a, 0x6e, 0x92, 0x71, 0x56,
	0x1e, 0x62, 0xa9, 0x31, 0xb6, 0xce, 0xce, 0x6a, 0x67, 0x0d, 0x64, 0x9c, 0x5d, 0x03, 0x8f, 0x71,
	0x87, 0x1a, 0xc3, 0xae, 0xc1, 0xc1, 0xdf, 0x0d, 0x5e, 0xd4, 0xa9, 0x1d, 0xc8, 0xfb, 0xc5, 0x80,
	0x1b, 0x9b, 0x6b, 0x24, 0x33, 0xb1, 0x4f, 0x48, 0x24, 0x13, 0xe4, 0xd7, 0x30, 0x33, 0x7b, 0x16,
	0x36, 0xd3, 0xb3, 0xad, 0x65, 0x56, 0xf4, 0x69, 0x60, 0x02, 0x41, 0x7f, 0x27, 0xc4, 0x84, 0xfa,
	0x3b, 0x72, 0x05, 0x63, 0xcb, 0xdf, 0x62, 0xd5, 0x4e, 0xdd, 0x59, 0x5d, 0xb4, 0xe4, 0x66, 0x94,
	0xc2, 0xa1, 0xce, 0x5c, 0x7d, 0x78, 0x74, 0xa2, 0x35, 0xff, 0x30, 0xee, 0x31, 0xc4, 0x79, 0x93,
	0xcd, 0xdf, 0xc1, 0xf4, 0x4f, 0x81, 0xc2, 0xf6, 0xd7, 0x1d, 0x5a, 0xc2, 0x93, 0x3e, 0xc1, 0x86,
	0xc4, 0x98, 0xba, 0xd7, 0xd5, 0x5d, 0xbd, 0x4d, 0xeb, 0xfa, 0x61, 0xf1, 0x9b, 0xd3, 0xd5, 0xb6,
	0x80, 0xbb, 0xad, 0x42, 0xbf, 0x2b, 0xf3, 0x7f, 0x46, 0xbc, 0xff, 0x7c, 0x76, 0xc9, 0x36, 0xff,
	0xdb, 0x37, 0xf3, 0xe6, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x20, 0x4e, 0x9d, 0x5f, 0xde, 0x03,
	0x00, 0x00,
}
